import dagger
from dagger import object_type, function, Directory, Container, dag, File, Doc, Secret
from typing import Annotated, Optional

@object_type
class Terraform:
    """
    Terraform Automation module refactored from Makefile.
    Supports multi-environment (dev/prod), automatic documentation, and secure secret handling.
    """

    @function
    def base(
        self,
        tf_version: Annotated[str, Doc("Terraform version to use")] = "1.9.0"
    ) -> Container:
        """
        Base container with Terraform and Terraform-docs installed.
        """
        tf_docs_version = "v0.19.0"
        
        return (
            dag.container()
            .from_("hashicorp/terraform:" + tf_version)
            # Instala dependências extras para docs e scripts
            .with_exec(["apk", "add", "--no-cache", "curl", "bash", "git"])
            # Instala terraform-docs
            .with_exec([
                "curl", "-Lo", "/usr/local/bin/terraform-docs",
                f"https://github.com/terraform-docs/terraform-docs/releases/download/{tf_docs_version}/terraform-docs-{tf_docs_version}-linux-amd64"
            ])
            .with_exec(["chmod", "+x", "/usr/local/bin/terraform-docs"])
        )

    @function
    async def plan(
        self,
        source: Annotated[Directory, Doc("Terraform source code")],
        env: Annotated[str, Doc("Environment (dev or prod)")] = "dev",
        dev_arn: Annotated[Optional[Secret], Doc("ARN for dev environment")] = None,
        prod_arn: Annotated[Optional[Secret], Doc("ARN for prod environment")] = None,
        cloudflare_token: Annotated[Optional[Secret], Doc("Cloudflare API Token")] = None,
        cloudflare_zone: Annotated[Optional[Secret], Doc("Cloudflare Zone ID")] = None,
    ) -> File:
        """
        Initializes and generates a Terraform execution plan.
        """
        container = await self._prepare_env(
            source, env, dev_arn, prod_arn, cloudflare_token, cloudflare_zone
        )
        
        plan_file = f"tfplan.{env}"
        
        return (
            container
            .with_exec(["terraform", "init", "-upgrade"])
            .with_exec(["terraform", "validate"])
            .with_exec(["terraform", "plan", "-no-color", "-input=false", f"-out={plan_file}"])
            .file(plan_file)
        )

    @function
    async def apply(
        self,
        source: Annotated[Directory, Doc("Terraform source code")],
        plan: Annotated[File, Doc("The plan file generated by the plan function")],
        env: Annotated[str, Doc("Environment (dev or prod)")] = "dev",
        dev_arn: Annotated[Optional[Secret], Doc("ARN for dev environment")] = None,
        prod_arn: Annotated[Optional[Secret], Doc("ARN for prod environment")] = None,
        cloudflare_token: Annotated[Optional[Secret], Doc("Cloudflare API Token")] = None,
        cloudflare_zone: Annotated[Optional[Secret], Doc("Cloudflare Zone ID")] = None,
    ) -> str:
        """
        Applies a previously generated Terraform plan.
        """
        plan_file = f"tfplan.{env}"
        container = await self._prepare_env(
            source, env, dev_arn, prod_arn, cloudflare_token, cloudflare_zone
        )
        
        return await (
            container
            .with_file(plan_file, plan)
            .with_exec(["terraform", "init"])
            .with_exec(["terraform", "apply", "-no-color", "-input=false", plan_file])
            .stdout()
        )

    @function
    async def docs(
        self,
        source: Annotated[Directory, Doc("Terraform source code")],
        config_file: Annotated[Optional[File], Doc("Path to .tfdocs-config.yml")] = None
    ) -> File:
        """
        Generates Markdown documentation using terraform-docs.
        """
        container = self.base().with_mounted_directory("/src", source).with_workdir("/src")
        
        if config_file:
            container = container.with_file("/src/.tfdocs-config.yml", config_file)
            
        return (
            container
            .with_exec(["sh", "-c", "terraform-docs markdown /src > README_generated.md"])
            .file("README_generated.md")
        )

    @function
    async def state_rm(
        self,
        source: Annotated[Directory, Doc("Terraform source code")],
        address: Annotated[str, Doc("The resource address to remove from state")],
        env: Annotated[str, Doc("Environment (dev or prod)")],
        dev_arn: Optional[Secret] = None,
        prod_arn: Optional[Secret] = None,
    ) -> str:
        """
        Removes an item from the Terraform state.
        """
        container = await self._prepare_env(source, env, dev_arn, prod_arn)
        return await (
            container
            .with_exec(["terraform", "init"])
            .with_exec(["terraform", "state", "rm", address])
            .stdout()
        )

    # --- Private Helper ---

    async def _prepare_env(
        self,
        source: Directory,
        env: str,
        dev_arn: Optional[Secret] = None,
        prod_arn: Optional[Secret] = None,
        cf_token: Optional[Secret] = None,
        cf_zone: Optional[Secret] = None,
    ) -> Container:
        """Sets up the container with secrets and environment variables."""
        
        # 1. Select ARN based on environment
        target_arn = dev_arn if env == "dev" else prod_arn
        if not target_arn:
            raise Exception(f"ARN for environment '{env}' must be provided as a Secret.")

        # 2. Build container
        ctr = (
            self.base()
            .with_mounted_directory("/src", source)
            .with_workdir("/src")
            # Injeta variáveis obrigatórias do Makefile
            .with_secret_variable("TF_VAR_iam_role_arn", target_arn)
        )

        if cf_token:
            ctr = ctr.with_secret_variable("CLOUDFLARE_API_TOKEN", cf_token)
        if cf_zone:
            ctr = ctr.with_secret_variable("CLOUDFLARE_ZONE_ID", cf_zone)

        return ctr